#!/bin/bash

# Usage: ./docker_etc_hosts [OPTIONS]

set -euo pipefail

# Exit on any command failure
trap 'echo "Error: Command failed on line $LINENO" >&2; exit 1' ERR

HOSTS_FILE="/etc/hosts"
DOMAIN="internal"
DRY_RUN=false

show_help() {
  cat << EOF
Update /etc/hosts with running Docker containers IPs and names

Usage: $0 [OPTIONS]

OPTIONS:
  --domain DOMAIN            Domain for containers (default: internal)
  --dry-run                  Write to stdout instead of updating a hosts file
  --hosts-file FILE          Target hosts file (default: /etc/hosts)
  -h, --help                 Show this help message

Container names are formatted as: container-name.DOMAIN
EOF
}

while [[ $# -gt 0 ]]; do
  case $1 in
    --domain)
      if [[ -z "${2-}" ]]; then
        echo "Error: --domain requires a value" >&2
        exit 1
      fi
      DOMAIN="$2"
      shift 2
      if [[ ! "$DOMAIN" =~ ^[a-z0-9]([a-z0-9.-]*[a-z0-9])?$ ]]; then
        echo "Error: Invalid --domain: $DOMAIN" >&2
        exit 1
      fi
      ;;
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    --hosts-file)
      if [[ -z "${2-}" ]]; then
        echo "Error: --hosts-file requires a value" >&2
        exit 1
      fi
      HOSTS_FILE="$2"
      shift 2
      ;;
    -h|--help)
      show_help
      exit
      ;;
    *)
      echo "Error: Unknown option $1" >&2
      exit 1
      ;;
  esac
done

to_hostname() {
  local name="$1"
  name="${name#/}"           # Remove leading slash
  name="${name//_/-}"        # Replace underscores with hyphens
  name="${name// /-}"        # Replace spaces with hyphens
  name="${name,,}"           # Convert to lowercase
  name=$(echo "$name" | sed 's/[^a-z0-9-]//g')  # Keep only alphanumeric and hyphens

  if [[ "$name" =~ ^[a-z0-9](.*[a-z0-9])*$ ]]; then
    echo "$name"
  else
    echo
  fi
}

get_docker_entries() {
  # Check if Docker is available and running
  if ! command -v docker >/dev/null 2>&1; then
    echo "Error: Docker command not found" >&2
    exit 1
  fi

  if ! docker info >/dev/null 2>&1; then
    echo "Error: Docker daemon is not running or not accessible" >&2
    exit 1
  fi

  local container_ids hostname ip name rest;
  container_ids=$(docker ps -q)

  # Perform this check manually instead of using the `-r` flag to `xargs`, b/c the latter isn't supported on macOS
  if [[ -z "$container_ids" ]]; then
    return
  fi

  echo "$container_ids" | xargs docker inspect --format "{{.Name}} {{range .NetworkSettings.Networks}}{{.IPAddress}} {{end}}" 2>/dev/null | while read -r name ip rest; do
    # Skip containers with no IP (e.g., host networking mode) or invalid IP
    if [[ -z "$ip" || "$ip" == "invalid" ]]; then
      continue
    fi
    if [[ -n "$rest" ]]; then
      echo "Error: Container $name has multiple IP addresses, which is not supported" >&2
      exit 1
    fi
    hostname=$(to_hostname "$name")
    if [[ -z "${hostname}" ]]; then
      echo "Error: The hostname derived from container '$name' is invalid: $hostname" >&2
      exit 1
    fi
    echo "$ip ${hostname}.${DOMAIN}"
  done | sort
}


update_hosts_file() {
  local entries="$1"

  if [[ ! -f "$HOSTS_FILE" ]]; then
    echo "Error: Hosts file $HOSTS_FILE does not exist" >&2
    exit 1
  fi

  if [[ ! -w "$HOSTS_FILE" ]]; then
    echo "Error: Cannot write to $HOSTS_FILE" >&2
    exit 1
  fi

  # Process each entry
  while IFS=' ' read -r ip hostname; do
    # Check if hostname exists and replace, otherwise append
    if grep -q "[0-9.]*[[:space:]]*$hostname" "$HOSTS_FILE"; then
      sed -i "s/[0-9.]*[[:space:]]*$hostname.*/$ip $hostname/" "$HOSTS_FILE"
    else
      echo "$ip $hostname" >> "$HOSTS_FILE"
    fi
  done <<< "$entries"
}

entries=$(get_docker_entries)

if [[ -z "$entries" ]]; then
  echo "Warning: No running Docker containers found with applicable network configurations" >&2
  exit
fi

if [[ "$DRY_RUN" == "true" ]]; then
  echo "$entries"
  exit
fi

update_hosts_file "$entries"
